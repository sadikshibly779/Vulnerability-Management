from flask import Flask, render_template, request, redirect, url_for, session, flash
from flask_bcrypt import Bcrypt
from flask_login import LoginManager, UserMixin, login_user, login_required, logout_user, current_user

import mysql.connector
from mysql.connector import pooling

app = Flask(__name__)
app.secret_key = b'M\xd3\xf1V\x0c\x08\x15F\xab\xf7\xc7/\xe4\x93E\xe6\x8a\xb0\xd9\xc0\x8e"\x98\xd5'
bcrypt = Bcrypt(app)

# Flask-Login configuration
login_manager = LoginManager(app)
login_manager.login_view = 'login'


# Your User class (replace with your actual User model)
class User(UserMixin):
    def __init__(self, user_id, username):
        self.id = user_id
        self.username = username


@login_manager.user_loader
def load_user(user_id):
    # Implement this function to load a user by their ID from your database
    # Example: return User(user_id, username)
    with db_pool.get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute('SELECT * FROM User WHERE UserID = %s', (user_id,))
            user_data = cursor.fetchone()
            if user_data:
                return User(user_data[0], user_data[1])  # Assuming columns are (UserID, UserName)
            return None

    
# Create a connection pool for database connections
db_pool = mysql.connector.pooling.MySQLConnectionPool(
    pool_name="db_pool",
    pool_size=5,
    host="localhost",
    user="root",
    password="",
    database="nope",
    port="3306",
)

def create_tables():
    try:
        with db_pool.get_connection() as conn:
            with conn.cursor() as cursor:
                # Create User table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS User (
                        UserID INT AUTO_INCREMENT PRIMARY KEY,
                        UserName VARCHAR(255),
                        Password VARCHAR(255)
                    )
                ''')

         

                # Create Vulnerability table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS Vulnerability (
                        VulnerabilityID INT AUTO_INCREMENT PRIMARY KEY,
                        Description TEXT,
                        Severity VARCHAR(255),
                        Status VARCHAR(255),
                        AffectedSystems TEXT,
                        RemediationSteps TEXT,
                        TeamID INT
                        
                    )
                ''')

                print("Tables created successfully")
    except Exception as e:
        print(f"Error creating tables: {e}")




def drop_tables():
    with db_pool.get_connection() as conn:
        with conn.cursor() as cursor:
            # Drop tables
            cursor.execute('DROP TABLE IF EXISTS Vulnerability')
            cursor.execute('DROP TABLE IF EXISTS Team')
            cursor.execute('DROP TABLE IF EXISTS User')

            print("Tables dropped successfully")
        
def get_vulnerabilities():
    with db_pool.get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute('SELECT * FROM Vulnerability')
            return cursor.fetchall()
            

# Home page - Display Teams, Users, and Vulnerabilities
@app.route('/')
def home():
    teams = "Niter_Neophytes"
    users = get_users()
    vulnerabilities = get_vulnerabilities()
    return render_template('home.html', teams=teams, users=users, vulnerabilities=vulnerabilities)


# User Registration
@app.route('/register', methods=['GET', 'POST'])
def register():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']
        hashed_password = bcrypt.generate_password_hash(password).decode('utf-8')

        with db_pool.get_connection() as conn:
            try:
                with conn.cursor() as cursor:
                    # Check if the username is already taken
                    cursor.execute('SELECT * FROM User WHERE UserName = %s', (username,))
                    existing_user = cursor.fetchone()

                    if existing_user:
                        flash('Username already taken. Please choose a different one.', 'error')
                        return redirect(url_for('register'))

                    # Insert the new user
                    cursor.execute('INSERT INTO User (UserName, Password) VALUES (%s, %s)', (username, hashed_password))
                conn.commit()
                flash('Registration successful. You can now log in.', 'success')
            except Exception as e:
                print(f"Error during registration: {e}")
                conn.rollback()
                flash('An error occurred during registration. Please try again.', 'error')

        return redirect(url_for('login'))

    return render_template('register.html')



@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        username = request.form['username']
        password = request.form['password']

        with db_pool.get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute('SELECT * FROM User WHERE UserName = %s', (username,))
                user = cursor.fetchone()

                if user and bcrypt.check_password_hash(user[2], password):
                    user_obj = User(user[0], user[1])  # Assuming columns are (UserID, UserName)
                    login_user(user_obj)  # Use Flask-Login to log in the user
                    return redirect(url_for('home'))

    return render_template('login.html')




# Logout
@app.route('/logout')
def logout():
    session.pop('user_id', None)
    return redirect(url_for('login'))



def user_exists(user_id):
    with db_pool.get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute('SELECT * FROM User WHERE UserID = %s', (user_id,))
            return cursor.fetchone() is not None





# Add Vulnerability without user authentication
@app.route('/add_vulnerability', methods=['GET', 'POST'])
def add_vulnerability():
    if request.method == 'POST':
        description = request.form['description']
        severity = request.form['severity']
        status = request.form['status']
        affected_systems = request.form['affectedSystem']
        remediation_steps = request.form['remediationSteps']

        # Set the TeamID to a constant value (e.g., 1)
        team_id = 1

        with db_pool.get_connection() as conn:
            with conn.cursor() as cursor:
                try:
                    cursor.execute('''
                        INSERT INTO Vulnerability 
                        (Description, Severity, Status, AffectedSystems, RemediationSteps, TeamID) 
                        VALUES (%s, %s, %s, %s, %s, %s)
                    ''', (description, severity, status, affected_systems, remediation_steps, 1))

                    conn.commit()  # Commit the transaction

                    flash('Vulnerability added successfully', 'success')
                    return redirect(url_for('home'))
                except Exception as e:
                    conn.rollback()  # Rollback the transaction in case of an error
                    print(f"Error inserting vulnerability: {e}")
                    flash('An error occurred while adding the vulnerability. Please try again.', 'error')

    return render_template('add_vulnerability.html', teams='NITER_Neophytes')


# List Vulnerabilities
@app.route('/vulnerabilities')
def list_vulnerabilities():
    if 'user_id' not in session:
        return redirect(url_for('login'))

    vulnerabilities = get_vulnerabilities()

    return render_template('list_vulnerabilities.html', vulnerabilities=vulnerabilities)

# Vulnerability Details
@app.route('/vulnerability/<int:vulnerability_id>')
def vulnerability_details(vulnerability_id):
    if 'user_id' not in session:
        return redirect(url_for('login'))

    vulnerability = get_vulnerability_details(vulnerability_id)

    return render_template('vulnerability_details.html', vulnerability=vulnerability)

@app.route('/search_results', methods=['GET', 'POST'])
def search_results():
    if request.method == 'POST':
        search_query = request.form['search_query']

        with db_pool.get_connection() as conn:
            with conn.cursor() as cursor:
                cursor.execute('SELECT * FROM Vulnerability WHERE Description LIKE %s', ('%' + search_query + '%',))
                search_results = cursor.fetchall()

        return render_template('search_results.html', search_query=search_query, search_results=search_results)

    return redirect(url_for('home'))

    

def get_search_results(search_query):
    with db_pool.get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute('SELECT * FROM Vulnerability WHERE Description LIKE %s', ('%' + search_query + '%',))
            return cursor.fetchall()


def get_users():
    with db_pool.get_connection() as conn:
        cursor = conn.cursor()
        cursor.execute('SELECT * FROM User')
        return cursor.fetchall()

def get_vulnerability_details(vulnerability_id):
    with db_pool.get_connection() as conn:
        with conn.cursor() as cursor:
            cursor.execute('SELECT * FROM Vulnerability WHERE VulnerabilityID = %s', (vulnerability_id,))
            return cursor.fetchone()

if __name__ == '__main__':
    with app.app_context():
        create_tables()
    app.run(debug=True)
